以太坊虚拟机（EVM）使用的是 **小端字节序（Little Endian）** 和 **大端字节序（Big Endian）** 的混合模式，这在处理数据时非常关键，尤其是在堆栈、内存和交易数据的编码中。以下是详细说明：

### **1. 什么是字节序？**

	字节序（Byte Order）是指计算机系统如何组织和存储多字节数据（如整数或浮点数）。常见的字节序有两种：
	• 大端字节序（Big Endian）：
		• 高位字节（Most Significant Byte，MSB）存储在地址的低位（最低内存地址）。
		• 例子：数值 0x12345678 被存储为：
```
	地址： 00 01 02 03
	值：  12 34 56 78
```

	• 小端字节序（Little Endian）：
		• 低位字节（Least Significant Byte，LSB）存储在地址的低位（最低内存地址）。
		• 例子：数值 0x12345678 被存储为：
```
	地址： 00 01 02 03
	值：  78 56 34 12
```

### **2. EVM 的字节序**

	EVM 在不同的数据结构中，使用了 **小端字节序** 和 **大端字节序** 的组合方式。以下是具体的应用场景：

##### **2.1. 堆栈操作中的字节序**

	• EVM 使用 大端字节序（Big Endian） 表示整数。
	• 堆栈中的所有操作数和结果都以 32 字节（256 位）的大端格式存储。
	• 解释：
		• 数值 0x1234 在堆栈中被存储为：
```
	0x0000000000000000000000000000000000000000000000000000000000001234
```
	• 高位字节排在最左边

**示例：PUSH1**
	PUSH1 0x01 会将 0x01 推入堆栈，实际存储为：
```
0x0000000000000000000000000000000000000000000000000000000000000001
```

##### **2.2. CALLDATA 和交易数据中的字节序**

	• 在交易数据（CALLDATA）中，EVM 使用 大端字节序（Big Endian） 表示数据。
	• 函数选择器和参数都使用大端格式编码，以便与 ABI（应用二进制接口）兼容。

**示例：ABI 编码**
	调用 transfer(address,uint256) 函数，输入数据为：
```
	0xa9059cbb + 000000000000000000000000recipient_address + 00000000000000000000000000000000000000000000000000000000000000amount
```

	• 函数选择器（0xa9059cbb）：
		• 大端字节序存储。
	• 地址参数 和 整型参数 ：
		• 地址 recipient_address 被填充为 32 字节，大端存储。
		• 数值 amount 被编码为 32 字节，大端存储。

##### **2.3. 内存中的字节序**

	• EVM 的内存是 字节寻址 ，以每个字节为单位操作。
	• 在内存中存储的多字节值是按照 大端字节序（Big Endian） 进行存储的。

**示例：存储整型数据**

	数值 0x1234 在内存中的存储为：
```
地址： 00 01 02 03 ...
值：  00 00 00 00 ... 00 12 34
```

##### **2.4. 存储（Storage）中的字节序**

	• EVM 的存储是按  256 位（32 字节） 的槽（slot）进行寻址。
	• 在存储槽中，数据是以 大端字节序（Big Endian） 存储的。
	• 例如，将数值 0x1234 存入一个存储槽时，其存储形式为：

```
0x0000000000000000000000000000000000000000000000000000000000001234
```

##### **2.5. LOG 指令中的字节序**

	• EVM 的 LOGx 指令生成事件日志。
	• 日志数据和主题（topics）也使用 大端字节序（Big Endian） 表示。

### **3. 为什么 EVM 选择大端字节序？**

• **与 ABI 的兼容性**：

	• 以太坊智能合约的 ABI 规范定义了大端格式用于函数选择器和参数的编码。

• **跨平台一致性**：

	• 使用大端字节序可以与其他大端格式的协议（如网络协议）无缝对接。

• **读取简单性**：

	• 高位字节在前，符合数学中数值书写习惯（从高到低）。

### **4. 小端字节序的应用场景**

	虽然 EVM 本身倾向于使用大端字节序，但在以下场景中会用到小端字节序：

##### **4.1. SHA3（Keccak-256）中的哈希计算**

	• 在对数据进行哈希计算时，EVM 使用小端字节序解释某些内部值。
	• 例如，对一个 256 位的值进行哈希计算时，底层实现可能依赖小端格式。

##### **4.2. 编译器和外部工具**

	• 编译器（如 Solidity）在一些底层实现上可能使用小端字节序，但对用户是透明的。

### **5. 示例：字节序的对比**

	假设我们有一个数值 0x12345678，以下展示其在不同场景中的存储方式：

![[字节序不同场景中的存储方式.png]]

### **6. 总结**

	• EVM 默认使用大端字节序（Big Endian） 处理数据，包括堆栈、内存、存储、交易输入（CALLDATA）和返回值。
	• 小端字节序（Little Endian） 在一些底层操作（如哈希计算）中会被用到，但对开发者通常不可见。
	• 理解字节序对处理 ABI 编码、调试数据结构和优化智能合约逻辑非常重要。


![[byte_order_1.png]]![[byte_order_2.png]]![[byte_order_3.png]]![[byte_order_4.png]]![[byte_order_5.png]]
