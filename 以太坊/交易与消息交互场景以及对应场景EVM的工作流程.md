![[交易与消息交互场景.png]]

### **纵向维度（To EOA vs To CA）**

#### 1. **To EOA（发送到外部账户）**

	• 目标是外部账户（EOA）。EOA 是由用户私钥控制的账户，存储了 ETH 和 nonce，但没有关联的合约代码。
	• 两种情况：
		• 由交易直接发起。
		• 通过合约代码间接发起。
#### 2. **To CA（发送到合约账户）**

	• 目标是合约账户（CA）。CA 是存储了特定合约代码的账户，由合约逻辑控制。
	• 两种情况：
		• 由交易直接发起（通常是用户调用合约函数或部署新合约）。
		• 通过合约代码间接发起（例如调用另一个合约函数）。

### **横向维度（From EOA vs From CA）**

#### 1. **By Transaction From EOA**

	• 交易由外部账户（EOA）发起，通常是用户通过钱包向其他账户发送交易。

	• 特点：

		• 交易需支付 Gas 费用，由发起账户签名和验证。
		• 可以发送 ETH 或调用合约（比如发送调用数据到合约）。

#### 2. **By EVM Code From CA**

	• 消息由合约账户（CA）发起，通常是合约代码内部的调用（例如 call 或 delegatecall）。

	• 特点：
		• 不需要新的签名，直接由合约逻辑触发。
		• 通过 EVM 的操作码执行消息发送。

### **图片四种场景解析**

#### **第一象限（By Transaction From EOA → To EOA）**

	• 描述：
		• 外部账户（EOA1）向另一个外部账户（EOA2）发送交易。
	• 常见场景：ETH 转账。
	• 特点：
		• 直接发起交易（Transaction）。
		• 消息（Message）携带 ETH 或数据。
		• 目标账户 EOA2 不会执行任何代码，只接受 ETH 或交易数据。
		
#### **第二象限（By EVM Code From CA → To EOA）**

	• 描述：
		• 合约账户（CA1）调用外部账户（EOA）。
	• 常见场景：合约触发退款逻辑，向用户账户（EOA）转账 ETH。
	• 特点：
		• 发起方是合约（CA1）的代码逻辑。
		• 消息（Message）由 call 操作触发。
		• 目标账户 EOA 只接受 ETH 或数据，不会执行任何代码。

#### **第三象限（By Transaction From EOA → To CA）**

	  • 描述：
		• 外部账户（EOA1）向合约账户（CA1）发送交易。
	• 常见场景：用户调用智能合约函数。
	• 特点：
		• 交易直接发起，并携带调用数据。
		• 目标账户（CA1）会执行合约代码。
		• 需要支付 Gas 来执行合约逻辑。

#### **第四象限（By EVM Code From CA → To CA）**

	• 描述：
		• 合约账户（CA1）调用另一个合约账户（CA2）。
		• 常见场景：合约间交互，例如多合约协作或代理模式。
	• 特点：
		• 调用由合约代码（CA1）触发。
		• 消息（Message）包含调用数据和 ETH。
		• 目标合约（CA2）会执行代码逻辑，继续处理调用。

### **交易和消息的区别**

  • **交易（Transaction）：**

		• 由用户（EOA）发起。
		• 需要支付 Gas。
		• 包含发送者签名。
		• 可以是转账（ETH）或调用合约（函数执行）。

• **消息（Message）：**

		• 在合约执行中由 EVM 触发。
		• 不需要签名。
		• 不需要额外 Gas 费用（由外层交易的 Gas 支付）。
		• 主要用于合约内部的交互。

### **实际应用场景**

![[交互场景区别.png]]

### 每种交互模式下 EVM 的执行逻辑

#### **第一象限：EOA → EOA（外部账户向外部账户发起交易）**

	交互描述：用户通过钱包发起交易（如 ETH 转账），交易由一个外部账户（EOA1）发送到另一个外部账户（EOA2）。
	
	EVM 工作流程：
		1.接收交易：
			• 交易由 EOA1 签名并通过节点广播到网络。
			• 交易数据包括发送者、接收者、转账金额、Gas 限制、Gas 价格等。
		2.交易验证：
			• 节点对交易的合法性进行验证：
			• 检查签名是否合法。
			• 检查发送者账户的余额是否足够支付交易金额和 Gas。
			• 如果验证失败，交易会被拒绝。
		3.执行转账：
			• EVM 执行账户状态的更新：
				• 从 EOA1 扣除 转账金额 + Gas 费用。
				• 将转账金额添加到 EOA2 的余额中。
				• 此过程中没有执行任何代码，因为 EOA 没有合约逻辑。
		4.生成结果：
			• 返回交易成功或失败的结果。
			• 若成功，交易记录被打包到区块链上。

#### **第二象限：CA → EOA（合约账户向外部账户发起消息）**

	交互描述：
		• 一个合约账户（CA1）向外部账户（EOA）发送消息（如转账 ETH）。
		• 典型场景是合约代码中通过 call 方式向外部账户转账。
	
	EVM 工作流程：
		1.触发消息发送：
			• 某个交易触发了 CA1 的合约代码（比如 EOA 调用了 CA1 的函数）。
			• 合约执行过程中通过 call 指令发送 ETH 到目标 EOA。
		2.执行消息逻辑：
			• EVM 从 CA1 的存储中读取需要发送的 ETH 数额。
			• 更新账户状态：
				• 从 CA1 的余额中扣除 ETH。
				• 将 ETH 添加到目标 EOA 的余额中。
		3. 无代码执行：
			• 由于目标账户是 EOA，没有合约逻辑，因此不需要执行任何代码。
			• 仅完成账户余额的更新。
		4. 返回结果：
			• 合约逻辑继续执行，call 指令返回成功或失败的状态。

#### **第三象限：EOA → CA（外部账户向合约账户发起交易）**

	交互描述：
		• 用户通过钱包发起交易，调用某个合约（CA）的函数。
		• 常见场景是用户与智能合约交互，如存款、取款或执行某种逻辑。

	EVM 工作流程：
		1.接收交易：
			• 交易由 EOA1 签名并通过网络广播。
			• 交易数据包括发送者、接收者（CA 地址）、调用数据（函数选择器和参数）、转账金额（可选）、Gas 限制和 Gas 价格。
		2.交易验证：
			• 节点对交易的合法性进行验证：
				• 检查签名是否合法。
				• 检查 EOA1 的余额是否足够支付 Gas 和转账金额。
		3.初始化执行环境：
			• EVM 创建一个执行上下文，用于执行目标合约（CA）的代码：
			• 创建独立的 栈、内存 和 存储。
			• 将调用数据载入内存。
			• 设置全局变量（如 msg.sender、msg.value 等）。
			• 初始化程序计数器（Program Counter, PC）。
		4. 执行合约代码：
			• EVM 根据调用数据解析函数选择器，定位要执行的函数。
			• 按照合约代码的操作码（Opcodes），逐步执行每条指令：
				• 修改存储（Storage）。
				• 读取内存（Memory）。
				• 进行数学计算。
				• 调用其他合约或发送 ETH。
		5. Gas 消耗：
			• 每执行一条指令都会消耗 Gas。
			• 如果 Gas 消耗完毕，则触发 Out of Gas 异常，执行回滚。
		6. 返回结果：
			• 执行完成后，返回结果数据（如果有）。
			• 交易状态记录到区块链中。

#### **第四象限：CA → CA（合约账户向合约账户发起消息）**

	交互描述：
		• 一个合约（CA1）调用另一个合约（CA2）的函数。
		• 常见场景是多合约协作，比如代理模式、跨合约逻辑调用等。

	EVM 工作流程：
		1. 触发消息：
			• 某个交易触发了 CA1 的合约代码。
			• 合约代码执行过程中通过 call、delegatecall 或 staticcall 调用 CA2。			2. 初始化子上下文：
			• EVM 为 CA2 创建新的执行上下文：
			• 新的栈和内存（Storage 不变，依赖调用方式）。
			• 传递调用数据（函数选择器和参数）。
			• 设置相关全局变量（如 msg.sender、msg.value 等，具体值取决于调用方式）。
		3. 执行 CA2 的合约代码：
			• CA2 按照传入的调用数据解析函数选择器，执行相应的代码。
			• 根据调用类型（call、delegatecall 或 staticcall）：
				• call： CA2 的存储独立，msg.sender 为 CA1。
				• delegatecall：共享 CA1 的存储，msg.sender 为原始调用者（EOA 或上一层合约）。
				• staticcall：不允许修改状态。
		4. 递归处理：
			• 如果 CA2 调用另一个合约（CA3），则重复步骤 1-3。
			• 每次调用会消耗额外 Gas。
		5. 返回结果：
			• CA2 执行完成后，将结果返回给 CA1。
			• CA1 根据结果决定后续逻辑。
		6. Gas 消耗：
			• 调用的 Gas 限制由父合约设置。
			• 未使用的 Gas 会返回给父合约。


### **总结**

	   这张图清晰地展示了以太坊账户之间的四种交互模式，分别覆盖了 **交易（Transaction）** 和 **消息（Message）** 的发起方式，以及不同账户（EOA 和 CA）的交互逻辑。在 EVM 中，EOA 和 CA 的交互通过这两种机制实现，而每种模式都有其独特的应用场景和特点。

	EVM 的执行特点

	1. 隔离性：
		• 每次调用（无论是交易还是消息）都有独立的执行上下文（栈、内存、程序计数器等）。
		• 存储（Storage）是每个合约独立的，但在 delegatecall 中共享。
	2. 递归执行：
		• 合约间调用是递归的，EVM 会为每次调用创建新的上下文，直到调用栈溢出或 Gas 用尽。
	3. 确定性：
		• EVM 的所有指令都是确定性的，输入相同则输出相同。
		• 这确保了交易结果可预测，便于共识达成。
	4. Gas 管理：
		• Gas 的消耗是 EVM 运行的核心：
			• 防止恶意合约消耗过多计算资源。
			• 未使用的 Gas 会返还给调用者。