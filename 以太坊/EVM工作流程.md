![[EVM工作流程.png]]

### **各个组件说明**

#### 1. **EVM Code（字节码）**

	• 合约被编译成字节码（Bytecode），EVM 读取字节码并逐条解释执行。
	• 每个指令（如 PUSH, POP, MSTORE, CALL 等）会通过操作码 (opcodes) 执行特定操作。

#### 2. **PC（程序计数器）**

	• PC（Program Counter）用于指示当前正在执行的字节码位置。
	• 每执行一条指令，PC 会自动增加，指向下一条待执行的字节码。
	• 跳转指令（如 JUMP 和 JUMPI）会修改 PC，使程序跳到指定的位置。

#### 3. **Operations（指令执行）**

	• Operations 表示执行的操作，比如加法、存储、加载等指令。
	• 指令从 EVM Code 中读取，通过栈操作（push 和 pop）进行计算。
	• 操作执行时会消耗 Gas，根据操作的复杂度和资源需求扣减 Gas。

#### 4. **Gas avail（剩余 Gas）**

	• Gas 表示执行指令的燃料，每条指令消耗的 Gas 不同。
	• 如果 Gas 消耗完，合约执行会被终止，状态会回滚。
	• Gas 用于防止恶意用户提交无限循环的代码，保障区块链网络安全。

#### 5. **Stack（栈）**

	• 栈 是 EVM 中的核心数据结构，具有 后进先出（LIFO） 的特性。
	• EVM 的栈最大深度为 1024。
	指令操作的输入和输出都通过栈传递：
		• PUSH 操作：将数据压入栈顶。
		• POP 操作：从栈顶移除数据。
		• 操作指令（如 ADD, SUB 等）：会从栈中取数，执行计算，再将结果压回栈顶。

#### 6. **Memory（内存）**

	• Memory 是临时的、线性分配的数据存储区域，随着合约执行分配和释放。
	• 在合约执行期间，数据可以存取，但 执行结束后会被清除 。
	• Memory 中的数据访问是 按字节 进行的，动态分配的数组、字符串等都会在这里存储。
	• 操作 Memory 的指令包括：
		• MLOAD：从 Memory 中加载数据到栈顶。
		• MSTORE：将栈顶数据存储到指定的 Memory 地址。
		• Memory 的使用会消耗 Gas，消耗量取决于分配的字节数。

#### 7. **(Account) Storage（存储）**

	• Storage 是持久化存储，用于保存智能合约的状态。
	• Storage 是合约账户的一部分，数据存储在全局状态树中，区块链上持久存在。
	• 访问 Storage 的指令：
		• SLOAD：从 Storage 中加载数据到栈顶（**耗费 Gas 高**）。
		• SSTORE：将栈顶数据存储到 Storage（修改数据会消耗更多 Gas）。
	• Storage 的访问比 Memory 和栈要慢得多，因为需要持久化到区块链上。


### **执行流程说明**

#### 1. **EVM 启动**

	• EVM 读取合约的字节码，从起始位置（PC = 0）开始执行。

#### 2. **指令执行**

	• 每条指令通过 PC 读取字节码。
	• 操作码交给 operations 模块执行，操作会涉及栈、Memory 和 Storage。

#### 3. **栈操作**

	• 操作码会从栈中取出输入数据，执行后将结果压回栈顶。

#### 4. **内存与存储访问**

	• 需要存取大量数据时：
		• Memory 用于临时存储数据。
		• Storage 用于持久化存储数据。
	• 读取和写入操作通过指令 MLOAD, MSTORE, SLOAD, SSTORE 实现。

#### 5. **Gas 消耗**

	• 每执行一条指令会消耗相应的 Gas。
	• 如果 Gas 耗尽，执行失败，状态回滚。

#### 6. **执行结束**

	• 程序执行完成后，EVM 会清理栈和内存，并将结果返回给调用方。
	• 如果涉及 Storage 修改，区块链状态树将更新。


### **总结**

这张图全面展示了 EVM 的工作机制，EVM 通过：

1. **栈**：管理操作码的输入输出。
2. **内存**：临时存储数据，执行结束后释放。
3. **存储**：持久化存储数据，消耗大量 Gas。
4. **Gas 管理**：确保网络资源不会被滥用。

这三个核心组件配合 **操作码指令** 实现了智能合约的执行流程，是 EVM 的基础运行机制。